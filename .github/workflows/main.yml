# name of the workflow
name: Build and Test

# This workflow performs on any push or pull action recognized in any branch
on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - '**'

# setting up the environmental variables 
#image from docker "nginx-proxy-manager"
# And the major version is set up to '2'
env:
  IMAGE: nginx-proxy-manager
  MAJOR_VERSION: '2'

# Setting up the jobs to perform first job is to setup the job
# purpose: setup the job
#tasks: 1. checks out the code from repository
# 2. reads the version from .version file
# 3. process the branch_name to create a lowercase, sanitized version

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      build_version: ${{ steps.get_version.outputs.version }}
      branch_lower: ${{ steps.get_branch.outputs.branch_lower }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Get Version
        id: get_version
        run: echo "version=$(cat .version)" >> $GITHUB_OUTPUT
      
      - name: Get Branch Name
        id: get_branch
        run: |
          BRANCH_NAME=${{ github.head_ref || github.ref_name }}
          echo "branch_lower=$(echo $BRANCH_NAME | tr '[:upper:]' '[:lower:]' | sed 's/[\\/\\.]/-/g')" >> $GITHUB_OUTPUT

# The Second job is to build the Job it follows up by setting up the job
# Its purpose is to compiles and prepares all application components
# key operayions:
#   1. sets up the node js environment with yarn cache
#   2. updates the version information in :
#     -frontend/package.json
#     -backend/package.json
#     -README.md
#   -Build three components:
#      -frontend application
#      -backend application
#      -Documentation
#   - Archives build outputs for use in subsequent jobs     


  build:
    needs: setup
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Cache Dependencies
        uses: actions/cache@v3
        with:
          path: |
            **/node_modules
            ~/.cache/yarn
            key: ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock') }}
            restore-keys: |
            ${{ runner.os }}-deps-
              
      # - name: Set up Node.js
      #   uses: actions/setup-node@v4
      #   with:
      #     node-version: '18'
      #     cache: 'yarn'
      
      # - name : Setup node.js
      #   uses: action/setup-node@v4
      #   with:
      #     node-version: '18'
      #     cache: 'yarn'
      
      - name: build dependencies
        run: |
          npm install
          npm ci

      - name: Yarn install or build
        run: |
          # Check if yarn.lock exists
          if [ -f "yarn.lock" ]; then
            echo "Using yarn for installation"
            yarn install
            yarn build
          else
            echo "Using npm for installation"
            npm ci
            npm run build
          fi
      
      - name: Install and Build
        run: |
          yarn install
          yarn build
          npm install
      
      - name: Update Version in Package Files
        run: |
          jq --arg v "${{ needs.setup.outputs.build_version }}" '.version = $v' frontend/package.json > tmp && mv tmp frontend/package.json
          jq --arg v "${{ needs.setup.outputs.build_version }}" '.version = $v' backend/package.json > tmp && mv tmp backend/package.json
          sed -i -E "s/(version-)[0-9]+\\.[0-9]+\\.[0-9]+(-green)/\\1${{ needs.setup.outputs.build_version }}\\2/" README.md
      
      - name: Build Frontend
        run: ./scripts/ci/frontend-build
      
      - name: Build Backend
        run: ./scripts/ci/test-and-build
      
      - name: Build Documentation
        working-directory: docs
        run: |
          yarn install
          yarn build
      
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            frontend/dist
            backend/dist
            docs/build


# TEST JOB:

# Then the workflow forwards to testing job here the purpose is
# purpose: Runs application tests across multiple database configuration

# features:
#   - uses matrix stattergy to test against three databases:
#     -SQLite
#     -mySQL
#     -PostgreSQL
#   - For each database configuration:
#     - Downloads build artifacts
#     - Sets up Docker BuildX
#     - Runs Cypress tests
#     - Captures debug logs on failure
#     - Archives test results
#     - Ensures clenup of Docker resources
    

            

  test:
    needs: [setup, build]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        database: [sqlite, mysql, postgres]
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Run Tests
        env:
          COMPOSE_PROJECT_NAME: npm_${{ needs.setup.outputs.branch_lower }}_${{ github.run_number }}_${{ matrix.database }}
          COMPOSE_FILE: docker/docker-compose.ci.yml:docker/docker-compose.ci.${{ matrix.database }}.yml
        run: |
          ./scripts/ci/fulltest-cypress
      
      - name: Save Debug Logs
        if: failure()
        run: |
          mkdir -p debug/${{ matrix.database }}
          docker-compose logs fullstack > debug/${{ matrix.database }}/docker_fullstack.log 2>&1
          docker-compose logs stepca > debug/${{ matrix.database }}/docker_stepca.log 2>&1
          docker-compose logs pdns > debug/${{ matrix.database }}/docker_pdns.log 2>&1
          docker-compose logs pdns-db > debug/${{ matrix.database }}/docker_pdns-db.log 2>&1
          docker-compose logs dnsrouter > debug/${{ matrix.database }}/docker_dnsrouter.log 2>&1
          
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.database }}
          path: |
            test/results/**/*
            debug/**/*
      
      - name: Cleanup
        if: always()
        run: docker-compose down --remove-orphans --volumes -t 30 || true

# DOCKER JOB:
#   purpose : Build and publishes the docker images

#   key operation:
#     - Requires successful completion of setup and test jobs
#     - sets up the docker buildx for multi-architecture builds
#     - Aunthentication with docker HUB
#     - Determines appropriate tags based on branch:
#       -For master branchl:
#         - version-specific tag
#         - major vesion tag
#         - Latest tag
#       - For other branches:
#         - Developement tag with branch name
#     - Builds and pushes multi-architecture images for:
#       - linux/amd64
#       - linux/arm64      


  docker:
    needs: [setup, test]
    if: success()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Set Docker Tags
        id: docker_tags
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            echo "tags=docker.io/jc21/${IMAGE}:${{ needs.setup.outputs.build_version }},docker.io/jc21/${IMAGE}:${MAJOR_VERSION},docker.io/jc21/${IMAGE}:latest" >> $GITHUB_OUTPUT
          else
            echo "tags=docker.io/nginxproxymanager/${IMAGE}-dev:${{ needs.setup.outputs.branch_lower }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Build and Push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.docker_tags.outputs.tags }}

# DOCUMENTAL JOB:
#   purpose : Triggers documentation updates.

#   conditions:
#     - Runs only on develop or master branches
#     - Requires successful Docker build
#     operations:
#       - Triggers external documenation repository build
#       - Requires successsful Docker build
#       - Uses Repository dispatch event for cross-repository communication

  docs:
    needs: [setup, docker]
    if: success() && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Docs Build
        uses: peter-evans/repository-dispatch@v2
        with:
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          repository: nginx-proxy-manager/nginx-proxy-manager-docs
          event-type: build-docs
          client-payload: '{"branch": "${{ github.ref_name }}"}'

# PR COMMENT JOB:
#   purpose: Provides feedback on pull requests.

#   conditions:
#     - runs only on pull requests
#     - Requires successful docker build
#   Operatons:
#     -Posts a comment on the PR with:
#       - Docker image location
#       - important usage notes
#       - Warning about backup requirements
      
  pr-comment:
    needs: [setup, docker]
    if: success() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const message = `Docker Image for build ${process.env.GITHUB_RUN_NUMBER} is available on
            [DockerHub](https://cloud.docker.com/repository/docker/nginxproxymanager/${process.env.IMAGE}-dev)
            as \`nginxproxymanager/${process.env.IMAGE}-dev:${process.env.BRANCH_LOWER}\`

            **Note:** ensure you backup your NPM instance before testing this image! Especially if there are database changes
            **Note:** this is a different docker image namespace than the official image`;
            
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
        env:
          IMAGE: ${{ env.IMAGE }}
          BRANCH_LOWER: ${{ needs.setup.outputs.branch_lower }}


# Secret Requirements:
#   The workflow requires these secrets to be configured:
#     - "DOCKERHUB_USERNAME" : Docker hub authentication username
#     - "DOCKERHUB_PASSWORD" : docker hub authentication passeord
#     - "REPO_ACCESS_TOKEN" : Github token for triggering documentation builds
 

# ERROR HANDLING:
#   - Test failures capture detailed logs for debugging
#   - Failed builds automatically clean up resources
#   - All artifacts are preserved for investigation
#   - Docker resources are cleaned up even if test fail
  
# BEST PRACTISES IMPLEMENTED:
#   1. parallel execution when possible
#   2. Artifact sharing between jobs
#   3. conditinal job execution
#   4. comprehensive error handling
#   5. resource cleanup
#   6. cross-platform compatibility
#   7. Secure credentials handling

    

